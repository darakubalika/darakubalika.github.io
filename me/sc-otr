function farmhay()
    local confirm = gg.alert("⚠️ WARNING\n\nare you sure you want to activate farm hay coin hack", "Yes", "No")
    if confirm ~= 1 then
        gg.toast("Cancelled")
        return
    end
    gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC)
    gg.searchNumber("2;2147483647;1497450502::9", gg.TYPE_DWORD)
    gg.refineNumber("2", gg.TYPE_DWORD)
    local results = gg.getResults(gg.getResultsCount())
    if #results == 0 then
        gg.toast("Not Found")
        return
    end
    local edits = {}
    for _, r in ipairs(results) do
        table.insert(edits, {address = r.address - 0x14, flags = gg.TYPE_DWORD, value = 2})
        table.insert(edits, {address = r.address + 0xC0, flags = gg.TYPE_DWORD, value = 2})
        table.insert(edits, {address = r.address + 0xC4, flags = gg.TYPE_FLOAT, value = 2e22})
        table.insert(edits, {address = r.address + 0xE0, flags = gg.TYPE_DWORD, value = 2})
        table.insert(edits, {address = r.address + 0xE4, flags = gg.TYPE_FLOAT, value = 2e22})
    end
    gg.setValues(edits)
    gg.toast("Success")
    gg.clearResults()
end

function nitroRepair()
    gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC)
    gg.searchNumber("2;30::5", gg.TYPE_FLOAT)
    local results = gg.getResults(gg.getResultsCount())
    if #results==0 then gg.toast("Not Found") return end
    local edits, freezes = {}, {}
    for _, r in ipairs(results) do
        if r.value==2 or r.value==30 then
            table.insert(edits,{address=r.address-0x4,flags=gg.TYPE_FLOAT,value=0})
            table.insert(edits,{address=r.address-0x8,flags=gg.TYPE_FLOAT,value=0})
            table.insert(freezes,{address=r.address,flags=gg.TYPE_FLOAT,value=0,freeze=true})
        end
    end
    if #edits>0 then gg.setValues(edits) end
    if #freezes>0 then gg.addListItems(freezes) end
    gg.toast("Succes")
    gg.clearResults()
end


gg.clearResults()
gg.setRanges(gg.REGION_C_ALLOC)

local crs = {
    "⌖ Carry", "⌖ Fury", "⌖ Ranger", "⌖ Karma", "⌖ Payback", "⌖ Dustmaker", "⌖ Buggy", "⌖ Stringer", "⌖ Split fire",
    "⌖ Lionheart", "⌖ Lionpaw", "⌖ Mudbee", "⌖ Iron maiden", "⌖ Sweetdream", "⌖ Caprice", "⌖ Gepard", "⌖ Defender",
    "⌖ Jupiter", "⌖ Inferno", "⌖ Mercury", "⌖ Meridian", "⌖ Novara", "⌖ RangerOG", "⌖ Somerset", "⌖ Moonwalker",
    "⌖ Moon rover", "⌖ Jazzy", "⌖ Legende", "⌖ Onyx", "⌖ Rainbow", "⌖ Vulcan", "⌖ Hellfire", "⌖ Carbonyeti", "⌖ Goldenyeti",
    "⌖ Taurus", "⌖ Hurricane", "⌖ Typhoon", "⌖ Union", "⌖ Aeon", "⌖ Icarus", "⌖ Voltage", "⌖ Peacemaker", "⌖ Behemoth",
    "⌖ Educator", "⌖ Goliath", "⌖ Tuky", "⌖ Rusty", "⌖ Poo Mobile", "⌖ Maximus", "⌖ Thunder", "⌖ School master", "⌖ Ursus", "⌖ Zed",
    "⌖ Firetruck", "⌖ Titan", "⌖ Titanium", "⌖ Dashund", "⌖ Hercules", "⌖ Icebreaker", ""
}

local vlu = {
    "32;64;400D::9", "72;72;400D::9", "75;68;750D::121", "220;72;800D::121", "72;72;800D::9",
    "140;72;1050D::121", "200;72;1050D::121", "35;82;1100D::121", "88;88;1100D::9", "120;82;1100D::121",
    "84;84;1100D::9", "0;40;76;1100D::13", "42;80;1250D::9", "60;84::5", "42;80;1300D::9",
    "55;89::5", "220;76;1200D::121", "65;88::5", "48;85", "65;86::5", "55;83::5", "56;87::5",
    "37;72::5", "210;76;1200D::121", "36;78::5", "80;80;1100D::9", "180;72;1050D;2::137", "42;87::5",
    "65;95::5", "34D;34D;36;72", "170;76;1200D::121", "76;76;1200D::9", "150;80;1200D::121",
    "90;90;1200D::9", "40;72;1200D;1.95::25", "200;82;1100D::121", "89;89;400D::9", "66;90::5",
    "60;86::5", "40;76;45000D::9", "40;76;1D::17", "180;88;1350D::121", "180;80;1200D::121",
    "43;92::5", "41;70::5", "23D;22D;40;72::501", "120;72;1200D::121", "42;67::5", "410;80;1350D::121",
    "42;85::5", "215;72;1200D::121", "1.10;80;1350D;2.5::133", "260;72;800D::121", "50;76;1000D::9",
    "40;88;1450D::9", "76;76;1450D::9", "340;88;1350D::121", "50;70;1550D::9", "62;74::5"
}

local off = {
    spd = {
        {0x14, gg.TYPE_FLOAT, 2e22},
        {0x18, gg.TYPE_FLOAT, 2e22},
        {0x1C, gg.TYPE_FLOAT, 2e22},
        {0x20, gg.TYPE_FLOAT, 2e22},
        {0x3C, gg.TYPE_DWORD, 99999},
        {0x40, gg.TYPE_DWORD, 99999},
        {0x44, gg.TYPE_DWORD, 99999},
        {0x48, gg.TYPE_DWORD, 99999},
        {0x6C, gg.TYPE_FLOAT, 4.8},
        {0x70, gg.TYPE_FLOAT, 4.8},
        {0x74, gg.TYPE_FLOAT, 5.0}, 
    }
}
local function apply_speed_to_base(baseAddr, speedFor074)
    local edits = {}
    for i = 1, #off.spd do
        local o = off.spd[i]
        local addr = baseAddr + o[1]
        local flags = o[2]
        local value = o[3]
        if o[1] == 0x74 and flags == gg.TYPE_FLOAT and speedFor074 then
            value = speedFor074
        end
        table.insert(edits, { address = addr, flags = flags, value = value })
    end
    gg.setValues(edits)
end
local function find_base_by_pattern(idx)
    local pat = vlu[idx]
    if not pat then return nil end

    gg.clearResults()
    gg.searchNumber(pat, gg.TYPE_FLOAT)
    local results = gg.getResults(2)
    if #results == 0 then
        gg.clearResults()
        return nil
    end
    local chosen = results[2] or results[1]
    local base = chosen.address
    gg.clearResults()
    return base
end

local function apply_speed_for_index(idx, speed)
    local base = find_base_by_pattern(idx)
    if not base then
        gg.alert("Car not found: " .. (crs[idx] or tostring(idx)))
        return false
    end
    apply_speed_to_base(base, speed)
    gg.toast("Speed " .. tostring(speed) .. " applied to: " .. (crs[idx] or tostring(idx)))
    return true
end

function spdcr()
    -- minta input speed dari user
    local defaultSpeed = "5.0"
    local input = gg.prompt({"Enter the speed value (float), for example 11.5"}, {defaultSpeed}, {"number"})
    if not input then return end
    local speedVal = tonumber(input[1])
    if not speedVal then
        gg.alert("Invalid value. Enter a decimal number (example: 11.5).")
        return
    end
    local cars = {}
    for i = 1, #crs-1 do
        table.insert(cars, crs[i])
    end

    local choices = gg.multiChoice(cars, nil, "Select cars to apply speed hack\nSpeed used: " .. tostring(speedVal))
    if not choices then return end

    for idx, selected in pairs(choices) do
        if selected then
            apply_speed_for_index(idx, speedVal)
        end
    end
end

function setLevel()
    local input = gg.prompt({"Enter Level:"}, {""}, {"number"})
    if not input or not input[1] or input[1] == "" then
        gg.toast("Empty input")
        return
    end
    local targetLvl = tonumber(input[1])

    gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC)
    gg.searchNumber("-1;0;561671348::77", gg.TYPE_DWORD)
    gg.refineNumber("-1", gg.TYPE_DWORD)
    local resA = gg.getResults(500)
    local baseA = resA[1] and resA[1].address or nil
    if not baseA then
        gg.toast("-1 not found")
        return
    end

    local addrCoin  = baseA + 0x30
    local addrLvl   = baseA + 0x1B8
    local addrMaxXP = baseA + 0x138

    gg.setValues({{address = addrMaxXP, flags = gg.TYPE_DWORD, value = 9999999}})
    gg.toast("Max XP set to 9,999,999")

    gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC)
    gg.searchNumber("1000;24;24;5:128", gg.TYPE_FLOAT)
    local resB = gg.getResults(500)
    local baseB
    for _, r in ipairs(resB) do
        if math.floor(r.value) == 5 then
            baseB = r.address
            break
        end
    end
    if not baseB then
        gg.toast("Anchor B (5) not found")
        return
    end
    local addrEnc = baseB - 0x290

    local val = targetLvl
    for i = 1, 3 do
        gg.setValues({{address = addrCoin, flags = gg.TYPE_DWORD, value = val}})
        gg.sleep(200)
        local tmp = gg.getValues({{address = addrEnc, flags = gg.TYPE_DWORD}})
        if #tmp == 0 then
            gg.toast("Failed to read Enc at step " .. i)
            return
        end
        val = tmp[1].value
        gg.toast("Step " .. i .. " | Enc=" .. val)
    end

    gg.setValues({{address = addrLvl, flags = gg.TYPE_DWORD, value = val}})
    gg.toast("Level changed to " .. targetLvl .. " (ENC: " .. val .. ")")
    gg.clearResults()
end


function setXp()
    local input = gg.prompt({"Enter XP:"}, {""}, {"number"})
    if not input or not input[1] or input[1] == "" then
        gg.toast("Empty input")
        return
    end
    local targetXp = tonumber(input[1])

    gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC)
    gg.searchNumber("-1;0;561671348::77", gg.TYPE_DWORD)
    gg.refineNumber("-1", gg.TYPE_DWORD)
    local resA = gg.getResults(500)
    local baseA = resA[1] and resA[1].address or nil
    if not baseA then
        gg.toast("-1 not found")
        return
    end

    local addrCoin = baseA + 0x30
    local addrXp   = baseA + 0x34

    gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC)
    gg.searchNumber("1000;24;24;5:128", gg.TYPE_FLOAT)
    local resB = gg.getResults(500)
    local baseB
    for _, r in ipairs(resB) do
        if math.floor(r.value) == 5 then
            baseB = r.address
            break
        end
    end
    if not baseB then
        gg.toast("Anchor B (5) not found")
        return
    end
    local addrEnc = baseB - 0x290

    local val = targetXp
    for i = 1, 3 do
        gg.setValues({{address = addrCoin, flags = gg.TYPE_DWORD, value = val}})
        gg.sleep(200)
        local tmp = gg.getValues({{address = addrEnc, flags = gg.TYPE_DWORD}})
        if #tmp == 0 then
            gg.toast("Failed to read Enc at step " .. i)
            return
        end
        val = tmp[1].value
        gg.toast("Step " .. i .. " | Enc=" .. val)
    end

    gg.setValues({{address = addrXp, flags = gg.TYPE_DWORD, value = val}})
    gg.toast("XP changed to " .. targetXp .. " (ENC: " .. val .. ")")
    gg.clearResults()
end


function setToken()
    local input = gg.prompt({"Enter Token:"}, {""}, {"number"})
    if not input or not input[1] or input[1] == "" then
        gg.toast("Empty input")
        return
    end
    local targetTkn = tonumber(input[1])

    gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC)
    gg.searchNumber("-1;0;561671348::77", gg.TYPE_DWORD)
    gg.refineNumber("-1", gg.TYPE_DWORD)
    local resA = gg.getResults(500)
    local baseA = resA[1] and resA[1].address or nil
    if not baseA then
        gg.toast("-1 not found")
        return
    end
    local addrCoin = baseA + 0x30
    local addrTkn  = baseA + 0x38

    gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC)
    gg.searchNumber("1000;24;24;5:128", gg.TYPE_FLOAT)
    local resB = gg.getResults(500)
    local baseB
    for _, r in ipairs(resB) do
        if math.floor(r.value) == 5 then
            baseB = r.address
            break
        end
    end
    if not baseB then
        gg.toast("Anchor B (5) not found")
        return
    end
    local addrEnc = baseB - 0x290

    local val = targetTkn
    for i = 1, 3 do
        gg.setValues({{address = addrCoin, flags = gg.TYPE_DWORD, value = val}})
        gg.sleep(200)
        local tmp = gg.getValues({{address = addrEnc, flags = gg.TYPE_DWORD}})
        if #tmp == 0 then
            gg.toast("Failed to read Enc at step " .. i)
            return
        end
        val = tmp[1].value
        gg.toast("Step " .. i .. " | Enc=" .. val)
    end

    gg.setValues({{address = addrTkn, flags = gg.TYPE_DWORD, value = val}})
    gg.toast("Token changed to " .. targetTkn .. " (ENC: " .. val .. ")")
    gg.clearResults()
end


function setTicket()
    local input = gg.prompt({"Enter Ticket:"}, {""}, {"number"})
    if not input or not input[1] or input[1] == "" then
        gg.toast("Empty input")
        return
    end
    local targetTic = tonumber(input[1])

    gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC)
    gg.searchNumber("-1;0;561671348::77", gg.TYPE_DWORD)
    gg.refineNumber("-1", gg.TYPE_DWORD)
    local resA = gg.getResults(500)
    local baseA = resA[1] and resA[1].address or nil
    if not baseA then
        gg.toast("-1 not found")
        return
    end
    local addrCoin = baseA + 0x30
    local addrTic  = baseA + 0x3C

    gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC)
    gg.searchNumber("1000;24;24;5:128", gg.TYPE_FLOAT)
    local resB = gg.getResults(500)
    local baseB
    for _, r in ipairs(resB) do
        if math.floor(r.value) == 5 then
            baseB = r.address
            break
        end
    end
    if not baseB then
        gg.toast("Anchor B (5) not found")
        return
    end
    local addrEnc = baseB - 0x290

    local val = targetTic
    for i = 1, 3 do
        gg.setValues({{address = addrCoin, flags = gg.TYPE_DWORD, value = val}})
        gg.sleep(200)
        local tmp = gg.getValues({{address = addrEnc, flags = gg.TYPE_DWORD}})
        if #tmp == 0 then
            gg.toast("Failed to read Enc at step " .. i)
            return
        end
        val = tmp[1].value
        gg.toast("Step " .. i .. " | Enc=" .. val)
    end

    gg.setValues({{address = addrTic, flags = gg.TYPE_DWORD, value = val}})
    gg.toast("Ticket changed to " .. targetTic .. " (ENC: " .. val .. ")")
    gg.clearResults()
end


function setLR()
    local input = gg.prompt({"Enter LR:"}, {""}, {"number"})
    if not input or not input[1] or input[1] == "" then
        gg.toast("Empty input")
        return
    end
    local targetLR = tonumber(input[1])

    gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC)
    gg.searchNumber("-1;0;561671348::77", gg.TYPE_DWORD)
    gg.refineNumber("-1", gg.TYPE_DWORD)
    local resA = gg.getResults(500)
    local baseA = resA[1] and resA[1].address or nil
    if not baseA then
        gg.toast("-1 not found")
        return
    end
    local addrCoin = baseA + 0x30
    local addrLR   = baseA + 0x44

    gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC)
    gg.searchNumber("1000;24;24;5:128", gg.TYPE_FLOAT)
    local resB = gg.getResults(500)
    local baseB
    for _, r in ipairs(resB) do
        if math.floor(r.value) == 5 then
            baseB = r.address
            break
        end
    end
    if not baseB then
        gg.toast("Anchor B (5) not found")
        return
    end
    local addrEnc = baseB - 0x290

    local val = targetLR
    for i = 1, 3 do
        gg.setValues({{address = addrCoin, flags = gg.TYPE_DWORD, value = val}})
        gg.sleep(200)
        local tmp = gg.getValues({{address = addrEnc, flags = gg.TYPE_DWORD}})
        if #tmp == 0 then
            gg.toast("Failed to read Enc at step " .. i)
            return
        end
        val = tmp[1].value
        gg.toast("Step " .. i .. " | Enc=" .. val)
    end

    gg.setValues({{address = addrLR, flags = gg.TYPE_DWORD, value = val}})
    gg.toast("LR changed to " .. targetLR .. " (ENC: " .. val .. ")")
    gg.clearResults()
end


function setNitroRepair()
    local maxVal = 2147483610

    gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC)
    gg.searchNumber("-1;0;561671348::77", gg.TYPE_DWORD)
    gg.refineNumber("-1", gg.TYPE_DWORD)
    local resA = gg.getResults(500)
    local baseA = resA[1] and resA[1].address or nil
    if not baseA then
        gg.toast("-1 not found")
        return
    end

    local addrNitro  = baseA + 0x2C
    local addrRepair = baseA + 0x28

    gg.setValues({
        {address = addrNitro, flags = gg.TYPE_DWORD, value = maxVal},
        {address = addrRepair, flags = gg.TYPE_DWORD, value = maxVal}
    })

    gg.toast("Nitro and Repair set to max (" .. maxVal .. ")")
    gg.clearResults()
end


function setAll()
    local inputs = gg.prompt(
        {"Enter Level:", "Enter XP:", "Enter Token:", "Enter Ticket:", "Enter LR:"},
        {"", "", "", "", ""},
        {"number", "number", "number", "number", "number"}
    )
    if not inputs then
        gg.toast("Input cancelled")
        return
    end

    local level  = tonumber(inputs[1]) or 0
    local xp     = tonumber(inputs[2]) or 0
    local token  = tonumber(inputs[3]) or 0
    local ticket = tonumber(inputs[4]) or 0
    local lr     = tonumber(inputs[5]) or 0

    local nitroRepair = gg.multiChoice({"Set Nitro & Repair to MAX"}, nil, "Nitro & Repair Option")

    gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC)
    gg.searchNumber("-1;0;561671348::77", gg.TYPE_DWORD)
    gg.refineNumber("-1", gg.TYPE_DWORD)
    local resA = gg.getResults(500)
    local baseA = resA[1] and resA[1].address or nil
    if not baseA then
        gg.toast("-1 not found")
        return
    end

    gg.clearResults()
    gg.setRanges(gg.REGION_C_ALLOC)
    gg.searchNumber("1000;24;24;5:128", gg.TYPE_FLOAT)
    local resB = gg.getResults(500)
    local baseB
    for _, r in ipairs(resB) do
        if math.floor(r.value) == 5 then
            baseB = r.address
            break
        end
    end
    if not baseB then
        gg.toast("Anchor B (5) not found")
        return
    end

    local addrCoin   = baseA + 0x30
    local addrEnc    = baseB - 0x290
    local addrMaxXP  = baseA + 0x138

    local function encodeAndSet(value, offsetFinal)
        local val = value
        for i = 1, 3 do
            gg.setValues({{address = addrCoin, flags = gg.TYPE_DWORD, value = val}})
            gg.sleep(200)
            local tmp = gg.getValues({{address = addrEnc, flags = gg.TYPE_DWORD}})
            if #tmp == 0 then
                gg.toast("Failed to read Enc at step " .. i)
                return false
            end
            val = tmp[1].value
        end
        local addrFinal = baseA + offsetFinal
        gg.setValues({{address = addrFinal, flags = gg.TYPE_DWORD, value = val}})
        return true
    end

    if level > 0 then
        if not encodeAndSet(level, 0x1B8) then return end
        gg.setValues({{address = addrMaxXP, flags = gg.TYPE_DWORD, value = 9999999}})
        gg.toast("Level changed to " .. level .. " and Max XP set to 9,999,999")
    end

    if xp > 0 then
        if not encodeAndSet(xp, 0x34) then return end
        gg.toast("XP changed to " .. xp)
    end

    if token > 0 then
        if not encodeAndSet(token, 0x38) then return end
        gg.toast("Token changed to " .. token)
    end

    if ticket > 0 then
        if not encodeAndSet(ticket, 0x3C) then return end
        gg.toast("Ticket changed to " .. ticket)
    end

    if lr > 0 then
        if not encodeAndSet(lr, 0x44) then return end
        gg.toast("LR changed to " .. lr)
    end

    if nitroRepair and nitroRepair[1] == true then
        setNitroRepair()
    end

    gg.toast("All changes completed")
    gg.clearResults()
end

function levelMenu()
    local confirm = gg.alert("⚠️ WARNING\n\nIf you use this script, make sure NOT to collect coins until the process is completely finished!")
    if confirm ~= 1 then
        gg.toast("Cancelled")
        return
    end
    local choice = gg.choice({
        "⌖ Level",
        "⌖ XP",
        "⌖ Token",
        "⌖ Ticket",
        "⌖ LR",
        "⌖ Nitro & Repair MAX",
        "⌖ Set All",
        "Back"
    }, nil, "Inventory Editor")
    if choice == 1 then setLevel() end
    if choice == 2 then setXp() end
    if choice == 3 then setTkn() end
    if choice == 4 then setTic() end
    if choice == 5 then setLR() end
    if choice == 6 then setNitroRepair() end
    if choice == 7 then setAll() end
end

function mainMenu()
    local menu=gg.choice({
        "➴️ Farm Hay Coin",
        "➴ Unlimited Nitro + Repair",
        "➴ Speed Car",
        "➴ Inventory Editor",
        "Exit"
    },nil,"Menu")

    if menu==1 then farmhay()
    elseif menu==2 then nitroRepair()
    elseif menu==3 then spdcr()
    elseif menu==4 then levelMenu() 
    elseif menu==5 then os.exit()
    end
end

while true do
    if gg.isVisible(true) then gg.setVisible(false) mainMenu() end
    gg.sleep(1)
end
